#!/bin/busybox sh

# Copyright (c) 2013-2014, CZ.NIC, z.s.p.o. (http://www.nic.cz/)
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the CZ.NIC nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL CZ.NIC BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#
# This file is interpreted as shell script.
# It contains firewall rules issued by CZ.NIC s.z.p.o.
# as a part of Turris project (see https://www.turris.cz/)
# 
# To enable/disable the rules please edit /etc/config/firewall
#
# config include
#   option path /usr/share/firewall/turris
#

# Enable debug
if [ -n "${DEBUG}" ] ; then
    set -x
fi


RULES_URL="https://api.turris.cz/firewall/turris-rules"
SIGN_URL="${RULES_URL}.sign"

IPSETS_URL="https://api.turris.cz/firewall/turris-ipsets"
IPSETS_SIGN_URL="${IPSETS_URL}.sign"

TMP_FILE="/tmp/iptables.rules"
TMP_FILE6="/tmp/ip6tables.rules"
PERSISTENT_RULES="/usr/share/firewall/turris-rules"
PERSISTENT_IPSETS="/usr/share/firewall/turris-ipsets"
ULOGD_FILE="/tmp/etc/ulogd-turris.conf"

DOWNLOAD_DIR="/tmp/fw-rules"
DOWNLOAD_RULES="${DOWNLOAD_DIR}/turris-rules"
DOWNLOAD_SIGN="${DOWNLOAD_RULES}.sign"
DOWNLOAD_IPSETS="${DOWNLOAD_DIR}/turris-ipsets"
DOWNLOAD_IPSETS_SIGN="${DOWNLOAD_IPSETS}.sign"

SIGN_KEY="/etc/ssl/turris-rules.pub"
DOWNLOAD_INTERVAL=$((4*60))
VERSION=$(opkg list-installed turris-firewall-rules | sed 's/[^0-9]*//')
WAN=""

TEST_SIGN_KEY="${DOWNLOAD_DIR}/turris-rules.pub"
TEST_SIGN_KEY_URL="https://api.turris.cz/firewall-test/turris-rules.pub"
TEST_RULES_URL="https://api.turris.cz/firewall-test/turris-rules"
TEST_SIGN_URL="${TEST_RULES_URL}.sign"
TEST_IPSETS_URL="https://api.turris.cz/firewall-test/turris-ipsets"
TEST_IPSETS_SIGN_URL="${TEST_IPSETS_URL}.sign"

while [ -z "${WAN}" ]; do
    . $IPKG_INSTROOT/lib/functions.sh

    # read wan from nikola
    config_load nikola
    config_get WAN main wan_ifname
    [ -n "${WAN}" ] && break

    # read wan from network
    config_load network
    config_get WAN wan ifname
    [ -n "${WAN}" ] && break

    # read wan from ucollect
    set_WAN() {
        local cfg="$1"
        config_get WAN "${cfg}" ifname
    }
    config_load ucollect
    config_foreach set_WAN interface
    [ -n "${WAN}" ] && break

    break
done

# Are ipset modules for ipset loaded
test_ipset_modules() {
    if [ -n "$(lsmod | grep ip_set)" ]; then
        return 0
    else
        return 1
    fi
}

# is NFLOG module loaded
test_nflog_modules() {
    if [ -n "$(lsmod | grep xt_NFLOG)" ]; then
        return 0
    else
        return 1
    fi
}

# Should load NFLOG
test_nflog() {
    if test_nflog_modules ; then
        # test using uci
        uci_val="$(uci -q get pcap-dumps.firewall.enabled)"
        if [ $? -eq 0 -a "$uci_val" = "1" ]; then
            return 0
        fi
    fi
    return 1
}

# Return md5 of a file the file should exist
file_md5() {
    local file="$1"
    echo $(md5sum "${file}" | sed 's/ .*//')
}


download() {
    local master_url="$1"
    local test_url="$2"
    local destination="$3"
    local interval="$4"

    if [ -n "$interval" ]; then
        if ! download_needed "${destination}" "${interval}" ; then
            return 0
        fi
    fi

    if [ "${test}" == "true" ]; then
        url="$test_url"
    else
        url="$master_url"
    fi

    curl -fs --cacert /etc/ssl/startcom.pem --crlfile /etc/ssl/crl.pem "${url}" -o "${destination}"
    if [ $? -eq 0 ]; then
        return 0
    else
        logger -t turris-firewall-rules "(v${VERSION}) Failed to download ${url}"
        return 1
    fi
}

# Check whether the selected file is older then X seconds
download_needed() {
    local file="$1"
    local seconds="$2"
    local current=`date +%s`
    if [ -f "${file}" ]; then
        local file_age=`date -r "${file}" +%s`
        if [ "${current}" -lt "$((file_age + seconds))" ] ; then
            return 1
        else
            return 0
        fi
        return 1
    else
        return 0
    fi
}

# Verifies signature
verify_signature() {

    local file="$1"
    local signature="$2"

    if [ "${test}" == "true" ]; then
        key="${TEST_SIGN_KEY}"
    else
        key="${SIGN_KEY}"
    fi

    openssl dgst -sha256 -verify "${key}" -signature "${signature}" "${file}" > /dev/null 2>&1
    return $?
}

# Update the persistent file
update_file() {

    local signature="$1"
    local downloaded="$2"
    local persistent="$3"
    local file_name=$(basename "${persistent}")

    # test the signature
    if [ -f "${signature}" -a -f "${downloaded}" ]; then
        verify_signature "${downloaded}" "${signature}"
        if [ $? -eq 1 ]; then
            logger -t turris-firewall-rules "(v${VERSION}) Incorrect signature for downloaded ${file_name}"
            return 1
        fi
    else
        return 1
    fi

    # Update the files
    if [ -f "${persistent}" ]; then
        cmp -s "${downloaded}" "${persistent}"
        if [ $? -eq 1 ]; then
            local new_md5=$(file_md5 "${downloaded}")
            local old_md5=$(file_md5 "${persistent}")
            logger -t turris-firewall-rules "(v${VERSION}) Switching ${file_name} ${old_md5} -> ${new_md5}"
            cp "${downloaded}" "${persistent}"
        fi
    else
        local new_md5=$(file_md5 "${downloaded}")
        logger -t turris-firewall-rules "(v${VERSION}) Setting ${file_name} ${new_md5}"
        cp "${downloaded}" "${persistent}"
    fi
}

# are we in the test branch?
test_branch() {

    if x=$(command -v getbranch) ; then
        branch=$(getbranch)
    else
        return 1
    fi

    if [ `getbranch` == "test" ] ; then
        return 0
    fi

    return 1
}

# create config for ulogd
make_ulogd_config() {
    local ids="$@"
    local idx=0

    # Part of a global section
    echo "# This file is generated using turris-firewall-rules any local changes will be destroyed." > "${ULOGD_FILE}"
    echo "[global]" >> "${ULOGD_FILE}"
    echo "plugin=\"/usr/lib/ulogd/ulogd_inppkt_NFLOG.so\"" >> "${ULOGD_FILE}"
    echo "plugin=\"/usr/lib/ulogd/ulogd_output_PCAP.so\"" >> "${ULOGD_FILE}"
    echo "plugin=\"/usr/lib/ulogd/ulogd_raw2packet_BASE.so\"" >> "${ULOGD_FILE}"

    # stacks
    for rule_id in $ids; do
        group_id=$(($idx + 1000))
        echo "stack=log${group_id}:NFLOG,base1:BASE,pcap${group_id}:PCAP" >> "${ULOGD_FILE}"
        idx=$(($idx + 1))
    done

    idx=0
    # sections
    for rule_id in $ids; do
        group_id=$(($idx + 1000))
        echo "[log${group_id}]" >> "${ULOGD_FILE}"
        echo "group=${group_id}" >> "${ULOGD_FILE}"
        echo "[pcap${group_id}]" >> "${ULOGD_FILE}"
        echo "file=\"/var/log/turris-${rule_id}.pcap\"" >> "${ULOGD_FILE}"
        echo "sync=1" >> "${ULOGD_FILE}"
        idx=$(($idx + 1))
    done
}

apply_iptables() {
    if [ -f "${PERSISTENT_RULES}" ]; then
        # Append header to file
        echo ':turris - [0:0]' >> "${TMP_FILE}"
        echo ':turris - [0:0]' >> "${TMP_FILE6}"
        eval echo "-I accept -o ${WAN} -j turris" >> "${TMP_FILE}"
        eval echo "-I accept -o ${WAN} -j turris" >> "${TMP_FILE6}"
        count=0
        count6=0
        while read line
        do
            ip=$(echo "${line}" | sed 's/.* -d \([^ ]*\) .*/\1/')
            if [ "${ip/:}" = "${ip}" ]; then
                # ipv4
                eval echo "${line}" >> "${TMP_FILE}"
                count=$((${count} + 1))
            else
                # ipv6
                eval echo "${line}" >> "${TMP_FILE6}"
                count6=$((${count6} + 1))
            fi
        done < "${PERSISTENT_RULES}"

        # Add the commit
        echo COMMIT >> "${TMP_FILE}"
        echo COMMIT >> "${TMP_FILE6}"

        # Apply iptables
        iptables-restore -T filter < "${TMP_FILE}"
        if [ $? -eq 0 ]; then
            logger -t turris-firewall-rules "(v${VERSION}) ${count} ipv4 rule(s) were loaded"
        else
            logger -t turris-firewall-rules "(v${VERSION}) Failed to load downloaded ipv4 rules"
            exit 1
        fi
        ip6tables-restore -T filter < "${TMP_FILE6}"
        if [ $? -eq 0 ]; then
            logger -t turris-firewall-rules "(v${VERSION}) ${count6} ipv6 rule(s) were loaded"
        else
            logger -t turris-firewall-rules "(v${VERSION}) Failed to load downloaded ipv6 rules"
            exit 1
        fi
    fi
}

apply_isets() {
    if [ -f "${PERSISTENT_IPSETS}" ]; then
        # Append header to files
        echo ':turris - [0:0]' >> "${TMP_FILE}"
        echo ':turris - [0:0]' >> "${TMP_FILE6}"
        eval echo "-I accept -o ${WAN} -j turris" >> "${TMP_FILE}"
        eval echo "-I accept -o ${WAN} -j turris" >> "${TMP_FILE6}"

        count="$(grep '^add [^ ]*_4' ${PERSISTENT_IPSETS} | wc -l)"
        count6="$(grep '^add [^ ]*_6' ${PERSISTENT_IPSETS} | wc -l)"

        # Load new ipsets
        ipset restore -f "${PERSISTENT_IPSETS}"

        # Create all if exist swap otherwise rename append rules
        old_names="$(ipset list | grep 'Name: turris_' | cut -d' ' -f2- | sort)"
        new_names="$(grep create ${PERSISTENT_IPSETS} | cut -d' ' -f2 | sort)"

        # Should NFLOG be activated (to be applied)
        nflog_idx=0
        if test_nflog ; then
            nflog="yes"

            rule_ids=$(echo "${new_names}" | cut -d_ -f2)
            make_ulogd_config "${rule_ids}"

            # restart ulogd
            /etc/init.d/ulogd restart
        fi

        # Create iptables rules
        for ipset_name in ${new_names}; do
            rule_id="$(echo ${ipset_name} | cut -d_ -f2)"
            action="$(echo ${ipset_name} | cut -d_ -f3)"
            type="$(echo ${ipset_name} | cut -d_ -f4)"
            ip_type="$(echo ${ipset_name} | cut -d_ -f5)"
            ipset_name_x="${ipset_name}_X"

            if [ "${old_names/${ipset_name_x}}" = "${old_names}" ]; then
                # set is brand new -> rename
                ipset rename "${ipset_name}" "${ipset_name_x}"
            else
                # set with is active -> swap and delete
                ipset swap "${ipset_name}" "${ipset_name_x}"
                ipset destroy "${ipset_name}"
            fi

            if [ "${ip_type}" = 4 ]; then
                target_file="${TMP_FILE}"
            elif [ "${ip_type}" = 6 ]; then
                target_file="${TMP_FILE6}"
            fi
            case "${action}" in
                "b")
                    if [ "${type}" = "a" ]; then
                        if [ "${nflog}" = "yes" ]; then
                            echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst -j NFLOG --nflog-group $((1000 + $nflog_idx))" >> "${target_file}"
                        fi
                        echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst -j DROP" >> "${target_file}"
                    elif [ "${type}" = "ap" ]; then
                        if [ "${nflog}" = "yes" ]; then
                            echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst,dst -j NFLOG --nflog-group $((1000 + $nflog_idx))" >> "${target_file}"
                        fi
                        echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst,dst -j DROP" >> "${target_file}"
                    fi
                    ;;
                "l")
                    if [ "${type}" = "a" ]; then
                        if [ "${nflog}" = "yes" ]; then
                            echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst -j NFLOG --nflog-group $((1000 + $nflog_idx))" >> "${target_file}"
                        fi
                        echo "-A turris -o ${WAN} -m limit --limit 1/sec -m set --match-set ${ipset_name_x} dst -j LOG --log-prefix \"turris-${rule_id}: \" --log-level debug" >> "${target_file}"
                    elif [ "${type}" = "ap" ]; then
                        if [ "${nflog}" = "yes" ]; then
                            echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst,dst -j NFLOG --nflog-group $((1000 + $nflog_idx))" >> "${target_file}"
                        fi
                        echo "-A turris -o ${WAN} -m limit --limit 1/sec -m set --match-set ${ipset_name_x} dst,dst -j LOG --log-prefix \"turris-${rule_id}: \" --log-level debug" >> "${target_file}"
                    fi
                    ;;
                "lb")
                    if [ "${type}" = "a" ]; then
                        if [ "${nflog}" = "yes" ]; then
                            echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst -j NFLOG --nflog-group $((1000 + $nflog_idx))" >> "${target_file}"
                        fi
                        echo "-A turris -o ${WAN} -m limit --limit 1/sec -m set --match-set ${ipset_name_x} dst -j LOG --log-prefix \"turris-${rule_id}: \" --log-level debug" >> "${target_file}"
                        echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst -j DROP" >> "${target_file}"
                    elif [ "${type}" = "ap" ]; then
                        if [ "${nflog}" = "yes" ]; then
                            echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst,dst -j NFLOG --nflog-group $((1000 + $nflog_idx))" >> "${target_file}"
                        fi
                        echo "-A turris -o ${WAN} -m limit --limit 1/sec -m set --match-set ${ipset_name_x} dst,dst -j LOG --log-prefix \"turris-${rule_id}: \" --log-level debug" >> "${target_file}"
                        echo "-A turris -o ${WAN} -m set --match-set ${ipset_name_x} dst,dst -j DROP" >> "${target_file}"
                    fi
                    ;;
            esac

            # increase nflog_group number
            nflog_idx=$(($nflog_idx + 1))
        done

        # Add the commit
        echo COMMIT >> "${TMP_FILE}"
        echo COMMIT >> "${TMP_FILE6}"

        # Apply iptables
        iptables-restore -T filter < "${TMP_FILE}"
        if [ $? -eq 1 ]; then
            logger -t turris-firewall-rules "(v${VERSION}) Failed to load downloaded ipv4 rules"
            exit 1
        fi
        ip6tables-restore -T filter < "${TMP_FILE6}"
        if [ $? -eq 1 ]; then
            logger -t turris-firewall-rules "(v${VERSION}) Failed to load downloaded ipv6 rules"
            exit 1
        fi

        logger -t turris-firewall-rules "(v${VERSION}) ${count} ipv4 address(es) and ${count6} ipv6 address(es) were loaded"
    fi
}

if [ -n "${WAN}" ]; then
    CHAIN="turris"

    if test_branch ; then
        if [ ! -f "${TEST_SIGN_KEY}" ] ; then
            curl -fs --cacert /etc/ssl/startcom.pem --crlfile /etc/ssl/crl.pem "${TEST_SIGN_KEY_URL}" -o "${TEST_SIGN_KEY}"
        fi
        test="true"
    else
        test="false"
    fi

    if test_ipset_modules ; then
        modules="true"
    else
        modules="false"
    fi

    # Don't any turris related rules and COMMIT
    iptables-save -t filter | grep -v '\-j turris' | grep -v '^-. turris' | grep -v '^:turris' | grep -v COMMIT > "${TMP_FILE}"
    ip6tables-save -t filter | grep -v '\-j turris' | grep -v '^-. turris' | grep -v '^:turris' | grep -v COMMIT > "${TMP_FILE6}"

    # Create directory for the rules
    mkdir -p "${DOWNLOAD_DIR}"

    # Try to update CRL
    get-api-crl 1>/dev/null 2>&1

    if test_ipset_modules ; then
        # Using ipset

        # Download the ipsets signature
        download "${IPSETS_SIGN_URL}" "${TEST_IPSETS_SIGN_URL}" "${DOWNLOAD_IPSETS_SIGN}" "${DOWNLOAD_INTERVAL}"

        # test whether is necessary to download the whole file
        if [ -f "${PERSISTENT_IPSETS}" ]; then
            verify_signature "${PERSISTENT_IPSETS}" "${DOWNLOAD_IPSETS_SIGN}"
            if [ $? -eq 0 ]; then
                # Skip when signature matches
                :
            else
                # download new rules
                download "${IPSETS_URL}" "${TEST_IPSETS_URL}" "${DOWNLOAD_IPSETS}"
            fi
        else
            download "${IPSETS_URL}" "${TEST_IPSETS_URL}" "${DOWNLOAD_IPSETS}"
        fi

        # update file in the persistent memory
        update_file "${DOWNLOAD_IPSETS_SIGN}" "${DOWNLOAD_IPSETS}" "${PERSISTENT_IPSETS}"

        # Apply the sets
        apply_isets

    else
        logger -t turris-firewall-rules "(v${VERSION}) Ipset modules not loaded using iptables instead"
        # Using iptables

        # Download the rule signature
        download "${SIGN_URL}" "${TEST_SIGN_URL}" "${DOWNLOAD_SIGN}" "${DOWNLOAD_INTERVAL}"

        # test whether is necessary to download the whole file
        if [ -f "${PERSISTENT_RULES}" ]; then
            verify_signature "${PERSISTENT_RULES}" "${DOWNLOAD_SIGN}"
            if [ $? -eq 0 ]; then
                # Skip when signature matches
                :
            else
                # download new rules
                download "${RULES_URL}" "${TEST_RULES_URL}" "${DOWNLOAD_RULES}"
            fi
        else
            download "${RULES_URL}" "${TEST_RULES_URL}" "${DOWNLOAD_RULES}"
        fi

        # update file in the persistent memory
        update_file "${DOWNLOAD_SIGN}" "${DOWNLOAD_RULES}" "${PERSISTENT_RULES}"

        # Apply the rules
        apply_iptables
    fi

    rm -f "${TMP_FILE}"
    rm -f "${TMP_FILE6}"
fi
