# This file is interpreted as shell script.
# It contains firewall rules issued by CZ.NIC s.z.p.o.
# as a part of Turris project (see https://www.turris.cz/)
# 
# To enable/disable the rules please edit /etc/config/firewall
#
# config include
#   option path /usr/share/firewall/turris
#

DOWNLOAD_DIR="/tmp/fw-rules"
RULES_URL="https://api.turris.cz/firewall/turris-rules"
SIGN_URL="${RULES_URL}.sign"
TMP_FILE="/tmp/iptables.rules"
PERSISTENT_RULES="/usr/share/firewall/turris-rules"
DOWNLOAD_RULES="${DOWNLOAD_DIR}/turris-rules"
DOWNLOAD_SIGN="${DOWNLOAD_RULES}.sign"
SIGN_KEY="/etc/ssl/turris-rules.pub"
DOWNLOAD_INTERVAL=$((4*60))
WAN=""

TEST_SIGN_KEY="${DOWNLOAD_DIR}/turris-rules.pub"
TEST_RULES_URL="https://api.turris.cz/firewall-test/turris-rules"
TEST_SIGN_KEY_URL="https://api.turris.cz/firewall-test/turris-rules.pub"
TEST_SIGN_URL="https://api.turris.cz/firewall-test/turris-rules.sign"

while [ -z "${WAN}" ]; do
    . $IPKG_INSTROOT/lib/functions.sh

    # read wan from nikola
    config_load nikola
    config_get WAN main wan_ifname
    [ -n "${WAN}" ] && break

    # read wan from network
    config_load network
    config_get WAN wan ifname
    [ -n "${WAN}" ] && break

    # read wan from ucollect
    set_WAN() {
        local cfg="$1"
        config_get WAN "${cfg}" ifname
    }
    config_load ucollect
    config_foreach set_WAN interface
    [ -n "${WAN}" ] && break

    break
done


# Return md5 of a file the file should exist
file_md5() {
    local file="$1"
    echo $(md5sum "${file}" | sed 's/ .*//')
}

# Download FW rules from the server
download_rules() {

    if [ "${test}" == "true" ]; then
        url="${TEST_RULES_URL}"
    else
        url="${RULES_URL}"
    fi

    curl -fs --cacert /etc/ssl/startcom.pem --crlfile /etc/ssl/crl.pem "${url}" -o "${DOWNLOAD_RULES}"

    if [ $? -eq 0 ]; then
        return 0
    else
        logger -t turris-firewall-rules "Failed to download ${url}"
        return 1
    fi
}

# Check whether the selected file is older then X seconds
download_needed() {
    local file="$1"
    local seconds="$2"
    local current=`date +%s`
    if [ -f "${file}" ]; then
        local file_age=`date -r "${file}" +%s`
        if [ "${current}" -lt "$((file_age + seconds))" ] ; then
            return 1
        else
            return 0
        fi
        return 1
    else
        return 0
    fi
}

# Download sign of the rules
download_sign() {

    if ! download_needed "${DOWNLOAD_SIGN}" "${DOWNLOAD_INTERVAL}" ; then
        return 0
    fi

    if [ "${test}" == "true" ]; then
        url="${TEST_SIGN_URL}"
    else
        url="${SIGN_URL}"
    fi

    curl -fs --cacert /etc/ssl/startcom.pem --crlfile /etc/ssl/crl.pem "${url}" -o "${DOWNLOAD_SIGN}"

    if [ $? -eq 0 ]; then
        return 0
    else
        logger -t turris-firewall-rules "Failed to download ${url}"
        return 1
    fi
}

# Verifies the signature
verify_signature() {

    if [ "${test}" == "true" ]; then
        key="${TEST_SIGN_KEY}"
    else
        key="${SIGN_KEY}"
    fi

    openssl dgst -sha256 -verify "${key}" -signature "${DOWNLOAD_SIGN}" "$1" > /dev/null 2>&1
    return $?
}

# Update the persistent file
update_file() {

    # test the signature
    if [ -f "${DOWNLOAD_SIGN}" -a -f "${DOWNLOAD_RULES}" ]; then
        verify_signature "${DOWNLOAD_RULES}"
        if [ $? -eq 1 ]; then
            logger -t turris-firewall-rules "Incorrect signature for downloaded rules"
            return 1
        fi
    else
        return 1
    fi

    # Update the files
    if [ -f "${PERSISTENT_RULES}" ]; then
        cmp -s "${DOWNLOAD_RULES}" "${PERSISTENT_RULES}"
        if [ $? -eq 1 ]; then
            local new_md5=$(file_md5 "${DOWNLOAD_RULES}")
            local old_md5=$(file_md5 "${PERSISTENT_RULES}")
            logger -t turris-firewall-rules "Switching fw rules ${old_md5} -> ${new_md5}"
            cp "${DOWNLOAD_RULES}" "${PERSISTENT_RULES}"
        fi
    else
        local new_md5=$(file_md5 "${DOWNLOAD_RULES}")
        logger -t turris-firewall-rules "Setting fw rules ${new_md5}"
        cp "${DOWNLOAD_RULES}" "${PERSISTENT_RULES}"
    fi
}

# are we in the test branch?
test_branch() {

    if x=$(command -v getbranch) ; then
        branch=$(getbranch)
    else
        return 1
    fi

    if [ `getbranch` == "test" ] ; then
        return 0
    fi

    return 1
}

if [ -n "${WAN}" ]; then
    CHAIN="turris"

    if test_branch ; then
        if [ ! -f "${TEST_SIGN_KEY}" ] ; then
            curl -fs --cacert /etc/ssl/startcom.pem --crlfile /etc/ssl/crl.pem "${TEST_SIGN_KEY_URL}" -o "${TEST_SIGN_KEY}"
        fi
        test="true"
    else
        test="false"
    fi

    # Don't store the the rules in turris chain and COMMIT
    iptables-save -t filter | grep -v '^-. turris' | grep -v COMMIT > "${TMP_FILE}"

    # Create directory for the rules
    mkdir -p "${DOWNLOAD_DIR}"

    # Try to update CRL
    get-api-crl 1>/dev/null 2>&1

    # Download the rule signature
    download_sign

    # Get signature instead of downloading the whole file
    if [ -f "${PERSISTENT_RULES}" ]; then
        verify_signature "${PERSISTENT_RULES}"
        if [ $? -eq 0 ]; then
            # Skip when signature matches
            :
        else
            # download new rules
            download_rules
        fi
    else
        download_rules
    fi

    # update file in the persistent memory
    update_file

    if [ -f "${PERSISTENT_RULES}" ]; then

        while read line
        do
            eval echo "${line}" >> "${TMP_FILE}"
        done < "${PERSISTENT_RULES}"

        # Add the commit
        echo COMMIT >> "${TMP_FILE}"

        iptables-restore -T filter < "${TMP_FILE}"
        if [ $? -eq 1 ]; then
            logger -t turris-firewall-rules "Failed to load downloaded rules"
            exit 1
        fi
    fi

    rm -f "${TMP_FILE}"
fi
